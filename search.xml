<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hello World</title>
      <link href="2020/12/27/hello-world/"/>
      <url>2020/12/27/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华三ACL</title>
      <link href="2020/06/24/H3C-ACL/"/>
      <url>2020/06/24/H3C-ACL/</url>
      
        <content type="html"><![CDATA[<p>ACL：access control lists控制访问列表<br>把路由器当做防火墙使用制定一系列规则。就是基于ACL<br>当想要限制一个网段访问另一个网段时，在不影响控制层面流量（不删除路由条目）的情况下，就可以基于ACL来实现。<br>基于IPv4 IPv6 IPx MAC ARP，可以直接使用acl（过滤流量）。<br>ACL是整个Internet中最低层的功能，三层功能，直接使用<br>创建一些比较高级的网络工具使用，这些高级的工具，调用ACL来实现某些高级的需求。<br>ACL用途<br>流量过滤：在路由器的接口直接调用ACL时，路由器可以限制从一个网络发出去往另一个网段的报文，可以阻止穿越路由器通行的报文<br>抓取兴趣流：当ACL被高级的工具调用一并使用的时候，acl可以定义我们想要作用的流量类型，可以使用低级的网络工具ACL来抓取兴趣流量，使用高级网络工具调用ACL，对一些兴趣流量做一些策略           使用更高级的策略嵌套acl使用<br>ACL用于过滤<br>直接把一个ACL在路由器的一个接口做一个调用，就可以实现过滤数据流量<br>一般情况，用ACL过滤数据流量时，ACL一般会包含多个访问控制规则，每个访问控制规则都称之为叫做ACE（access control entry）访问控制条目<br>一个ACL由多个ACE组成<br>实现数据层面的路由过滤：当把ACL在路由器的一个接口调用之后，这个接口想要转发报文时，需要经过每条ACE的匹配一个ACE就限制了来自什么地方去往什么地方的流量是否能通过，只有一个ACE允许流量通过的时候，这个流量才能被发送，反之，如果没有一个ACE允许通过，则直接被拒绝<br>实现控制层面的路由过滤：在VTY接口调用ACL，实现当一台PC，想要telnet ssh tftp路由器的时候，路由器会优先判断这个PC的IP地址是不是ACL匹配的，如果被匹配，就可以telnet ssh ，如果不匹配，就不能telnet ssh ，即使出示了正确的用户名和密码也不能实现远程网管<br>如果没有配置ACL任何报文都可以在网络中随意通行，只要路由器有相应的路由条目<br>直接调用，过滤流量：<br>在物理接口调用实现数据层面流量的过滤<br>在vty接口调用实现管理层面流量：telnet ssh tftp ftp<br>？制层面流量：hello报文 传递路由条目(控制路由表的生成)<br>ACL在被网络高级工具调用时，用于分类，流量抓取嵌套acl<br>ipsec vpn：整个Internet环境中最安全的一个VPN机制，实现当一个常量的流量想要通过VPN发送另一个场景时发送的流量是以加密的形式发送的<br>运行ipsec vpn需要制定该园区网哪个网段的PC发送流量去往另一个园区网的哪个网段的PC时，流量需要被保护<br>重分发：一个路由器既运行EIGRP又运行OSPF，默认两个进程不会传递路由<br>ACL可以用来抓取控制层面的路由条目<br>执行重分发时默认该路由器会把它获悉的所有来自OSPF的路由直接引入Eigrp域，使用ACL就可以让某些OSPF的路由引到Eigrp中<br>NAT：在NAT中调入ACL可以告知一台路由器什么样的PC发送的报文去往公网之前要给它做一个地址转换<br>直接在路由器的物理主接口调用ACL是可以选择调动方向的：<br>入向调用：该ACL只会作用于通过这个接口接收到的流量<br>出向调用：当路由器需要通过这个接口转发流量的时候，使用ACL调用<br>出向调用ACL（路由表高于ACL优先级）<br>路由器通过一个接口收到一个数据包，首先会查找路由表，看看是否有路由条目，如果没有报文直接被丢弃，如果有相应的路由条目选择适当的出战接口准备转发，然后查看该接口有没有调用出站方向的ACL，如果没有，报文就直接发走；如果有，就进行ACL的匹配，如果有一条ACL匹配就发送，没有就丢弃<br>只能过滤穿越流量，不能过滤路由器自己生成的流量<br>入向调用ACL（ACL优先级高于路由表）<br>如果在路由器入站方向调用ACL时，路由器收到一个数据包时先匹配ACL再查路由表；<br>可以实现所有接收流量的过滤。<br>ACL的匹配原则<br>ACL有多个ACE在匹配的时候按照一个顺序来一条一条匹配<br>这个顺序取决于每个ACE的序列号，默认创建一个ACL所写的第一个ACE的序列号缺省为10，第二个为20，第三个为30<br>ACL创建出来之后，所有的ACE都是按照序列号从小到大排序的<br>最小的在最上面，最大的在最下面<br>当使用ACL来匹配数据包时，会从上往下匹配<br>当使用ACL来匹配报文时，只要有一个ACE匹配到报文，这个ACE会立即执行策略，接下来不管还有多少个ACE都不再继续匹配<br>一个ACL至少需要配一个ACE，通过命令来配置的ACE称为显式ACE<br>隐式ACE永远为该ACL序列最大的ACE，默认隐式ACE能够匹配来自于任何源去往任何目的的任何流量，这个隐式ACE只要匹配到流量，该流量一定会被丢弃 Deny<br>一个报文进入路由器ACL怎样匹配？<br>首先匹配第一个ACE看执行的结果是Permit还是Deny<br>如果匹配到并且是Permit，就会转发，Deny直接丢弃<br>如果匹配到最后一条时，直接丢弃<br>Types  of  ACLS<br>基于IPV4的ACL<br>标准的ACL（Standard ACL）：只能基于流量的源IP地址来决定是否允许这个流量通行<br>只能基于流量的源来允许或过滤任何流量<br>过滤颗粒度极大（原因要么允许你来自某个源的一切流量，要么拒绝你来自某个源的一切流量<br>扩展的ACL（Extended ACL）：能基于源目IP地址来决定是否允许这个流量通行<br>可以允许或拒绝某些协议的流量，可以同时基于源目IP地址，<br>上层协议号以及源目端口号来实现流量的精确控制<br>创建标准ACL和扩展ACL的方式<br>以数字的方式来创建ACL  ACL的名称为纯阿拉伯数字<br>以命名式的方式来创建ACL  可包含数字，字符，符号等一系列信息<br>当ACL的编号为纯数字时 1-99，1300-1999  标准ACL<br>                        100-199，2000-2699  扩展ACL<br>命名式的ACL，可手工通过来选择该ACL是标准ACL还是扩展ACL，任意选择名称 后面跟着standard 或者extended 来指定标准还是扩展<br>IOS版本12.3以上创建ACL的灵活性<br> (1)12.3版本前，某个ACL的ACE写错了，只能把整个ACL删除，不能单独删除ACE<br>(2)12.3版本后，可以单独把ACE删除，再重新创建<br>(1)12.3版本前，默认写的第一个ACE为10，不能改变，每个ACE都间隔为10s，不能在中间添加<br>(2)12.3版本后，可以指定ACE的序列号来创建<br>配置ACL的原则<br>需要根据需求创建相应的标准ACL和扩展ACL来过滤想要过滤的流量<br>创建完要调用时，一台路由器的一个接口基于一个协议站以及一个方向只能调用一个ACL，路由器的一个接口入向可以调用一个ACL，出向也可以调用一个ACL<br>ACL匹配时，使用序列号自顶向下匹配<br>每一个ACL的最后端总会有一个隐藏Deny任何的语句，所以想要创建一个ACL，在显式的ACE中至少包含一条Permit语句<br>ACL使用全局模式创建，创建完之后在接口配置模式入向或出向调用，过滤数据层面的流量，<br>ACL可以过滤穿越路由器的流量<br>当调用标准ACL时，尽可能地靠近目的地址调用<br>当调用扩展ACL时，尽可能地靠近流量的源调用<br>静态ACL与动态ACL<br>标准ACL扩展ACL都成为静态ACL，当一个接口调用静态ACL后，这个接口自从调用该ACL开始，这个静态ACL就会一直工作，永远也不会停止<br>动态ACL<br>要创建动态ACL，里面只能包含一条动态ACE，默认这条动态ACE是不能工作的，需要动作触发<br>在路由器的一个接口调用了一个带有动态ACE的ACL，默认动态的ACE不会工作，可以用PC Telnent到路由器出示正确的用户名和密码，路由器判断这个PC是合法的PC，这个路由器会为这个PC自动开放一个动态的ACE，让这个ACE暂时性的工作，当不用时，经过一段时间会不工作<br>Ip  access-list  extended  X （名字）创建扩展ACL<br>Permit  [协议]  [SIP] 反码 [DIP] 反码  允许什么协议的从…到…<br>Dymic  test  permit  ip  host  [SIP]  host  [DIP]  动态ACL<br>Host 就相当于反码0.0.0.0<br>Autocommand  X  password  X  创建本地认证库<br>在接口调用先创建认证<br>Line vty 0 4<br>Autocommand access-enable host<br>Login local<br>进入另一个接口调用<br>Ip access-group X in  在入站方向调用<br>删除ACL  no ip access-list extended X<br>基于时间的ACL<br>Time-range X （名字）<br>Absolute start 时：分：秒 日 月（英语标识）年 end时：分：秒 日 月 年  立即生效时间<br>全局：access-list X（数字） permit  [协议]  [SIP] 反码 [DIP] 反码 time-range X 启用时间 /echo 可永久ping通<br>进接口调用 ip access-group X in<br>特权：set clock 时：分：秒 日 月（英语标识） 年<br>Ping X.X.X.X repeat X 可以pingX次<br>自反ACL<br>内网访问外网直接发送，外网需要验证<br>同一个接口调用，不同方向<br>中间设备<br>Ip access-list extend [名字] （不能为纯数字）<br>Permit ip[SIP] 0.0.0.255 [DIP] 0.0.0.255 reflect X 自反ACE名字<br>Ip access-list extend [名字] （不能为纯数字）<br>Permit ip host [SIP] host [DIP] 指定外网可以进内网<br>Evaluate X (自反ACE的名字)<br>进靠近外网的接口调用<br>出方向调用自反的ACL<br>如方向调用外网的ACL<br>默认内网ping外网可以通，外网ping内网不通<br>反码全为0用host，全为1用any<br>标准ACL使用IP地址和反码匹配流量的源<br>扩展ACL可以使用IP地址+反码+IP地址+反码来匹配流量的源和目的<br>标准的IPV4 ACL 纯三层工具，只会抓取三层报头的SIP地址<br>创建ACL：access-list 数字 permit/deny [SIP] 反码<br>调用物理接口：ip access-group 数字 in（入向）/out（出向）<br>在vty调用：access-class 数字 in<br>做管理层面的控制<br>Access-list 数字 permit 192.168.1.0 0.0.0.255<br>Line vty 0 4<br>Access-class 数字 in<br>只能被192.168.1.0网段的PC进行网管<br>扩展的IPV4 ACL 四层工具 即可匹配三层信息又可匹配四层信息<br>可以基于三层报头中的SIP，DIP地址或者协议号<br>如果是TCP/UDP报文还可以基于源目端口号来做流量的允许或拒绝的工作<br>创建：access-list 数字 permit/deny 协议号 SIP 反码 源反码 源端口号  （如果没写，代表任意的端口号都可以匹配） DIP 目的反码 目的端口号<br>对于TCP或UDP某些高级服务流量做允许或过滤一般只会写目的端口号<br>Ip access-group 数字 in/out 物理接口调用<br>Access-list 数字 permit ip any any  ip代表的任何流量<br>允许来自任何源去往任何目的的任何流量<br>Eq代表等于<br>Show ip access-list 查看状态<br>Show time-range 查看设置的时间<br>版本12.3以上的命名式ACL<br>Ip access-list standard/extended name（可以为纯数字）<br>序列号 permit/deny SIP反码  标准<br>序列号 permit/deny SIP反码 DIP 反码 扩展<br>Ip access-group name in/out 调用<br>Show access-list 显示ACL<br>如果要增加ACE或删除ACL要进入ACL中<br>ip access-list st name<br>X permit SIP<br>No X<br>扩展 ip access-list exended name<br>增加 X permit 协议号 SIP 反码 DIP 反码 eq x<br>Permit直接调用代表允许流量通过<br>       被高级工具调用时时匹配，仅仅用来抓取兴趣流<br>运用zone-based policy firewall 把路由器完全模拟为防火墙<br>zone-based就是路由器上能使用的基于自反ACL原理的最高级的工具<br>中间路由器配置<br>定义zone：Zone security name1 内网<br>Zone security name2 外网<br>定义class-map：Class-map type inspect match-all Icmp（name）<br>                Match protocol icmp<br>Exit<br>Class-map type inspect match-all HTTP（name）<br>                Match protocol http<br>Exit<br>Class-map type inspect match-all FTP（name）<br>                Match protocol ftp<br>Exit<br>Class-map type inspect match-all telnet<br>                Match protocol telnet<br>Exit<br>policy-map type inspect match-all name<br>class type inspect ICMP<br>inspect<br>class type inspect Telnet<br>inspect<br>class type inspect http<br>inspect<br>class type inspect ftp<br>inspect<br>exit<br>做路由策略<br>Zone-pair security 名字 source name2<br>Service-policy type inspect name<br>允许内网访问外网，但是流量全部被监测<br>Exit<br>Zone-pair security 名字 source name1 destination name2<br>Service-policy type inspect name<br>Exit<br>把相应的接口划入相应的zone<br>连接内网的接口<br>Zone-member security name1<br>连接外网的接口<br>Zone-member security name2<br>挂上之后，两者发送的流量都会被审计，可以基于审计信息来做一些比较高端的策略，比如：发现外网想要攻击内网时，可以直接把流量干掉<br> <br>已使用 Microsoft OneNote 2016 创建。</p>]]></content>
      
      
      <categories>
          
          <category> 华三数通 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> --华三 --ACL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LSA</title>
      <link href="2020/06/01/LSA/"/>
      <url>2020/06/01/LSA/</url>
      
        <content type="html"><![CDATA[<p><img src="./1.jpg"></p><h1 id="LSA"><a href="#LSA" class="headerlink" title="LSA"></a>LSA</h1><h2 id="LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。"><a href="#LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。" class="headerlink" title="LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。"></a>LSA头部信息，除Hello报文外，其它的OSPF报文都携带LSA信息。</h2><pre><code>• LS age：此字段表示LSA已经生存的时间，单位是秒。• Option：该字段指出了部分OSPF域中LSA能够支持的可选性能。• LS type：此字段标识了LSA的格式和功能。常用的LSA类型有五种。• Link State ID：根据LSA的不用而不同。• Advertising Router：始发LSA的路由器的ID。• Sequence Number：当LSA每次新的实例产生时，这个序列号就会增加。这个更新可以帮助其他路由器识别最新的LSA实例。• Checksum：关于LSA的全部信息的校验和。因为Age字段，所以校验和会随着老化时间的增大而每次都需要重新进行计算。• Length：是一个包含LSA头部在内的LSA的长度。</code></pre><h2 id="Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。"><a href="#Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。" class="headerlink" title="Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。"></a>Router-LSA，Router-LSA必须描述始发路由器所有接口或链路。</h2><pre><code>• Link State ID：是指始发路由器的路由器ID。• Flag：    ○ V：设置为1时，说明始发路由器是一条或者多条具有完全邻接关系的虚链路的一个端点。    ○ E：当始发路由器是一个ASBR路由器时，该为置为1。    ○ B：当始发路由器是一个ABR路由器时，该为置为1。• Number of links：表明一个LSA所描述的路由器链路数量。• Link Type：    ○ 值为1表示为点到点网络，常见的PPP链路需要使用点到点网络描述。    ○ 值为2表示连接一个transit网络，有至少两台路由器的广播型网段或NBMA网段就是一种Transit网段。    ○ 值为3表示连接stubnet网络，一般该网络上不存在邻居关系，如只有一个出口的以太网或回环接口。    ○ 值为4表示虚链路。• Link ID：    ○ Link Type为1时该值表示邻居路由器的路由器ID。    ○ Link Type为2时该值表示DR路由器的接口的IP地址。    ○ Link Type为3时该值表示IP网络或子网地址。    ○ Link Type为4时该值表示邻居路由器的路由器ID。• Link Data：    ○ Link Type为1时该值表示和网络相连的始发路由器接口的IP地址。    ○ Link Type为2时该值表示和网络相连的始发路由器接口的IP地址。    ○ Link Type为3时该值表示网络的子网掩码。    ○ Link Type为4时该值表示始发路由器的虚链路接口的IP地址。• ToS，暂不支持。• Metric：是指一条链路或接口的代价。</code></pre><h2 id="Network-LSA"><a href="#Network-LSA" class="headerlink" title="Network-LSA"></a>Network-LSA</h2><pre><code>• Link State ID：是指DR路由器的接口地址。• Network Mask：指定这个网络上使用的地址或者子网的掩码。• Attached router：列出该多路访问网络上与DR形成完全邻接关系且包括DR本身的所有路由器的路由器ID。</code></pre><h2 id="Network-summary-LSA和ASBR-summary-LSA"><a href="#Network-summary-LSA和ASBR-summary-LSA" class="headerlink" title="Network-summary-LSA和ASBR-summary-LSA"></a>Network-summary-LSA和ASBR-summary-LSA</h2><pre><code>• Link State ID：对于3类LSA来说，表示所通告的网络或子网的IP地址。对于4类LSA来说表示所通告的ASBR路由器的路由器ID。• Network Mask：对于3类LSA来说，表示所通告的网络的子网掩码。对于4类LSA来说，该字段没有实际意义，一般置为0.0.0.0。• Metric：始发路由器到目的地址的路由的代价。</code></pre><h2 id="AS-external-LSA"><a href="#AS-external-LSA" class="headerlink" title="AS-external-LSA"></a>AS-external-LSA</h2><pre><code>• Link State ID：表示所通告的网络或子网的IP地址。• Network Mask:指所通告的网络的子网掩码。• E：用来指定这条路由使用的外部度量的类型。如果该E bit设置为1,那么度量类型就是E2;如果该E bit设置为0,那么度量类型就是E1。• Metric：指路由的代价。由ASBR设定。• Forwarding Address：是指到达所通告的目的地的数据包应该被转发到的地址。如果转发地址是0.0.0.0,那么数据包将被转发到始发ASBR上。• External Route Tag:标记外部路由。</code></pre><h2 id="NSSA-LSA"><a href="#NSSA-LSA" class="headerlink" title="NSSA LSA"></a>NSSA LSA</h2><pre><code>• Forwarding Address：如果所引入外部路由的下一跳在OSPF路由域内，则Forwarding Address直接设置为所引入外部路由的下一跳；如果所引入外部路由的下一跳不在OSPF路由域内，则Forwarding Address设置为该ASBR上某个OSPF路由域内的Stub网段（例如Loopback0接口）的接口IP地址，有多个Stub网段时选IP地址最大者。（应该是：优选环回口地址，没有环回口使用物理接口地址。）    ○ </code></pre>]]></content>
      
      
      <categories>
          
          <category> 华为数通 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LSA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python列表概述</title>
      <link href="2020/03/27/python%E5%88%97%E8%A1%A8%E6%A6%82%E8%BF%B0/"/>
      <url>2020/03/27/python%E5%88%97%E8%A1%A8%E6%A6%82%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="循环和列表"><a href="#循环和列表" class="headerlink" title="循环和列表"></a>循环和列表</h1><h2 id="一、列表"><a href="#一、列表" class="headerlink" title="一、列表"></a>一、列表</h2><p>在python中，有这样一些类型，它们的成员是有序排列的，并且可以通过下标访问成员，这些类型称之为序列，包括：列表、range、元组和字符串；其中列表的成员可修改，属于可变序列，字符串和元组，成员不可修改，属于不可变序列。序列有共同操作：</p><ul><li>成员关系运算（in,not in)</li><li>连接操作（+）</li><li>重复操作（*）</li><li>切片操作（[::]）</li></ul><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h3><p>引出：存储一个数据可以采用变量</p><p>问题：需要同时存储多个数据，该怎么做？</p><pre><code>#需求：有5个人的年龄，求平均年龄age1 = 10age2 = 32age3 = 43age4 = 18age5 = 90average = (age1 + age2 + age3 + age4 + age5) / 5</code></pre><p>解决：容器【Python提供了一种数据结构list，可以同时存储多个数据】</p><p>本质：一种有序的集合</p><h3 id="2-创建列表"><a href="#2-创建列表" class="headerlink" title="2 创建列表"></a>2 创建列表</h3><p>语法：列表名 = [列表选项一，列表选项二，列表选项三…..]</p><p>说明：使用[]表示列表，列表名其实就是标识符</p><p>​     将列表中的列表选项被称为元素</p><p>​    列表中的元素分别被编了号，这些编号被称为索引【下标，角标】</p><p>​     列表索引： </p><p>​                从左向右开始编号：0,1,2….n-1</p><p>​                       从右向左编号:  -1,-2……</p><p>​                    -7   -6    -5    -4    -3  -2    -1</p><p>​                  [10 , 20 , 30 , 40, 50 ,90, 80]</p><p>​                    0      1     2     3   4      5    6</p><pre><code>list1 = []  #创建一个空列表list2 = [10,9,True,&#39;张三&#39;]list3 = list()  #创建一个空列表list4 = list(&#39;hello world)  # [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;, &#39; &#39;, &#39;w&#39;, &#39;o&#39;, &#39;r&#39;, &#39;l&#39;, &#39;d&#39;]</code></pre><h3 id="3-列表中元素的访问"><a href="#3-列表中元素的访问" class="headerlink" title="3.列表中元素的访问"></a>3.列表中元素的访问</h3><p>列表中元素不能整体访问，只能单个存取</p><h4 id="3-1取值"><a href="#3-1取值" class="headerlink" title="3.1取值"></a>3.1取值</h4><p>语法：列表名[索引]</p><pre><code>list1 = [1,2,4,3,8]num = list1[2]print(num)#下标越界，引发IndexError， 需要自己确定不要越界print(list1[5])</code></pre><h4 id="3-2-修改"><a href="#3-2-修改" class="headerlink" title="3.2 修改"></a>3.2 修改</h4><p>语法：列表名[索引] = 新的元素值</p><pre><code>list1[2] = 888print(list1)</code></pre><h3 id="3-3-遍历"><a href="#3-3-遍历" class="headerlink" title="3.3 遍历"></a>3.3 遍历</h3><p>列表的遍历就是访问列表的每一个元素，可以使用while循环和for-in循环。经常使用for-in循环遍历列表</p><p>for-in语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for 变量名 in 列表：</span><br><span class="line">     语句A</span><br><span class="line">else:</span><br><span class="line">      语句B</span><br></pre></td></tr></table></figure><p>说明：主要用于遍历序列【遍历：依次访问序列中的每一个元素,获取元素值】</p><p>工作原理：按照顺序获取列表中的每个元素，赋值给变量，再执行语句A，以此类推，直到列表中的元素全部获取为止，循环终止后执行else语句块。</p><ul><li>不要在for-in循环中添加或删除元素</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#只能获取元素，不能得到元素的下标</span><br><span class="line">for value in list1:</span><br><span class="line">print(value,end&#x3D;&#39; &#39;)</span><br><span class="line"></span><br><span class="line">#index表示下标，num表示元素值</span><br><span class="line">#enumerate将列表变成一个索引序列，同时包含下标和数据</span><br><span class="line">for index,num in enumerate(list1):</span><br><span class="line">    print(index,num)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#二维列表的遍历，循环嵌套</span><br><span class="line">l1 &#x3D; [[1,2],[3,4],[5,6]]</span><br><span class="line">for elem in l1:</span><br><span class="line">    for value in elem:</span><br><span class="line">        print(value, end&#x3D;&#39; &#39;)</span><br><span class="line">    print(&#39;&#39;)</span><br></pre></td></tr></table></figure><h3 id="4-序列的通用操作"><a href="#4-序列的通用操作" class="headerlink" title="4.序列的通用操作"></a>4.序列的通用操作</h3><pre><code>#1.列表组合  将两个列表拼接为一个列表#直接使用加号list1 = [43,65,76,6]list2 = [45,77,90,11,2,4,66]print(list1 + list2)  #[43,65,76,6,45,77,90,11,2,4,66]  产生一个新列表#2.列表重复#直接使用乘号 列表内容重复指定遍数，产生一个新列表print(list1 * 2)  # [43,65,76,6，43,65,76,6]#3.成员操作#成员运算符：in      not in#运算的结果为布尔值list3 = [&quot;hello&quot;,False,189,&quot;good&quot;]print(189 in list3) #Trueprint(180 not in list3)  #True#4.列表的截取【分片，切片】#语法：列表名[开始下标:结束下标：步长]，表示按指定步长获取从开始下标到结束下标之间的元素，#     结果为一个新的列表#注意：包头不包尾【前闭后开区间】   [开始下标,结束下标)#步长：默认是1，正数表示从左向右取，负数表示从右向左取list1 = [10,20,30,40,50,60]print(list1[0:3])   #[10,20,30]print(list1[:3])    #[10,20,30]print(list1[:])     #[10,20,30,40,50,60] 从头取到尾print(list1[::2])     # [10,30,50] 隔一个取一个print(list1[3::-1])  #[40, 30, 20, 10]  从右向左取print(list1[-1:-3:-1]) #[60, 50] 从右向左取print(list1[2:]) #[30, 40, 50, 60] 从下标为2的元素开始取到末尾print(list1[-3::-1])#[40, 30, 20, 10] 从右向左取到第一个元素#5.列表长度print(len(list1))#6.列表最大值和最小值、求和print(max(list1))print(min(list1))print(sum(list1))</code></pre><h3 id="5-列表的操作"><a href="#5-列表的操作" class="headerlink" title="5.列表的操作"></a>5.列表的操作</h3><p>l1 = [10,20,30]</p><h4 id="5-1-增加元素"><a href="#5-1-增加元素" class="headerlink" title="5.1 增加元素"></a>5.1 增加元素</h4><pre><code>#1. list.append(obj) 在列表末尾添加新的元素l1.append(40) #可以是普通元素 #l1[len(l1):len(l1)] = [40] #等价于l1.append(40)print(l1)     # [10,20,30,40] l1.append([50,60]) #也可以是其它列表、元组、字典、集合等对象print(l1)     # [10,20,30,40,[50, 60]]#2. list.extend(obj)  在列表的末尾一次性追加另一个列表中的元素#obj不能是单个数值，可以是列表等可迭代对象l1.extend([70,80])  #只是将元素添加到l1末尾print(l1)#3. list.insert(i,obj) 在指定下标i的位置插入一个新元素，原来的元素后移，不会覆盖l1.insert(1,-20)print(l1)    #[10, -20, 20, 30, 70, 80]l1.insert(0,[1,2,3])print(l1)   #[[1, 2, 3], 10, -20, 20, 30, 70, 80]</code></pre><h4 id="5-2-删除元素"><a href="#5-2-删除元素" class="headerlink" title="5.2 删除元素"></a>5.2 删除元素</h4><pre><code>#1. list.pop(i) 删除指定下标的元素，如果下标越界，会出现IndexErrorvalue = l1.pop()   #删除最后一个元素，并返回该元素的值print(value)print(l1)l1.pop(0)   #删除下标为0的元素print(l1)#2. list.remove(x) 删除列表中第一个值等于x的元素，删除的时候是从左向右找到第一个等于x的元素删除l1.remove(-20)print(l1)# l1.remove(100) 如果列表中没有该值，会引起错误：ValueError#3.按下标删除del l1[0]del l1[0:2]  #删除第一个和第二个元素#3 list.clear()  清空列表l1.clear()print(l1)  #[]</code></pre><h4 id="5-3-查找元素"><a href="#5-3-查找元素" class="headerlink" title="5.3 查找元素"></a>5.3 查找元素</h4><pre><code>#1. list.index(x,start,end) 在[start  end)范围内查找第一个等于x的元素的下标#参数说明： x 要查找的元素； start，开始下标；end 结束下标，不包含结束下标#返回值：如果有值等于x的元素，返回其下标，如果不存在值等于x的元素，会引发ValueErrorprint(l1.index(10))    #1print(l1.index(330,2,5))  #4#2 list.count(x) 查找列表中x出现的次数，如果没有x，返回0print(l1.count(30))   #2print(l1.count(99))   #0 不存在99</code></pre><h4 id="5-4-列表反转"><a href="#5-4-列表反转" class="headerlink" title="5.4 列表反转"></a>5.4 列表反转</h4><pre><code>#把列表元素逆序排列l1.reverse()print(l1)</code></pre><h4 id="5-5-列表排序"><a href="#5-5-列表排序" class="headerlink" title="5.5 列表排序"></a>5.5 列表排序</h4><pre><code>#1. list.sort(key=None,reverse=None) 列表方法，实现列表就地排序，不产生新列表#参数：key参数指明用哪个函数进行排序，默认值是None，用&lt;进行比较  可选参数      reserse：布尔值，默认值是None，也就是假，从小到大排序，如果设置为True，则从大到小排序，可选参数l1 = [90,30,70,20,10,60]print(l1)  # [90, 30, 70, 20, 10, 60]l1.sort()print(l1)  # [10, 20, 30, 60, 70, 90]</code></pre><h3 id="6-二维列表"><a href="#6-二维列表" class="headerlink" title="6 二维列表"></a>6 二维列表</h3><p>就是列表的元素还是列表</p><pre><code>list1 = [[1,2,3],[4,5,6]]#获取元素print(list1[0][0],list1[0][1],list1[0][2]) #1  2  3</code></pre><h3 id="7-range"><a href="#7-range" class="headerlink" title="7.range"></a>7.range</h3><p>系统提供内建函数range(start,end,[step=1])，生成一个等差序列[start, end)，注意序列属于不可变序列，不支持元素修改，不支持+和*操作。range一般用于for-in循环遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#range(start,end,step&#x3D;1)</span><br><span class="line">#参数：start，开始值，默认是0；</span><br><span class="line">#      end 结束值（序列不包括该值），必须大于start</span><br><span class="line">r1 &#x3D; range(1,11) #[1,2,3...10]</span><br><span class="line">r2 &#x3D; range(10)  #[1,2,3,...9]</span><br><span class="line">r3 &#x3D; range(1,11,2)  #[1,3,5,7,9]</span><br><span class="line"></span><br><span class="line">#求1+2+....+100的和</span><br><span class="line">sum &#x3D; 0</span><br><span class="line">for i in range(1,101):</span><br><span class="line">    sum +&#x3D; i</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">#求100以内的偶数和</span><br><span class="line">sum &#x3D; 0</span><br><span class="line">for i in range(0,100,2):</span><br><span class="line">sum +&#x3D; i</span><br><span class="line">print(sum)</span><br><span class="line"></span><br><span class="line">#按下标列表遍历</span><br><span class="line">l1 &#x3D; [10,80,65,43,90]</span><br><span class="line">i &#x3D; 0</span><br><span class="line">while i &lt; len(l1)：</span><br><span class="line">print(i,l1[i])</span><br><span class="line"></span><br><span class="line">#或者</span><br><span class="line">for i in range(len(l1)):</span><br><span class="line">    print(i,l1[i])</span><br></pre></td></tr></table></figure><h3 id="8-随机数"><a href="#8-随机数" class="headerlink" title="8.随机数"></a>8.随机数</h3><p>import  random</p><table><thead><tr><th align="center">函数名</th><th align="center">函数说明</th></tr></thead><tbody><tr><td align="center">choice(seq)</td><td align="center">返回一个序列（列表、元组，字符串）中返回一个随机元素</td></tr><tr><td align="center">randrange(start,end,step)</td><td align="center">start 指定范围的起始值 包含本身   end 指定范围的结束值 不包含本身 step 步长</td></tr><tr><td align="center">randint()</td><td align="center">返回一个随机整数</td></tr><tr><td align="center">shuffle(seq)</td><td align="center">将序列元素随机排列（打乱顺序）</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>简述git命令</title>
      <link href="2020/03/02/%E7%AE%80%E8%BF%B0hexo%E5%91%BD%E4%BB%A4/"/>
      <url>2020/03/02/%E7%AE%80%E8%BF%B0hexo%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>第一次搭建个人博客</title>
      <link href="2020/02/14/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>2020/02/14/%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p><img src="./5443.jpg"></p><p>利用github搭建个人博客已经成了喜闻乐见的东西<br>接下来讲解一下如何使用hexo+github快速搭建自己的博客</p><h2 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一  准备工作"></a>一  准备工作</h2><h3 id="1-下载git"><a href="#1-下载git" class="headerlink" title="1.下载git"></a>1.下载git</h3><p>地址：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a><br>按照顺序安装</p><h4 id="安装成功"><a href="#安装成功" class="headerlink" title="安装成功"></a>安装成功</h4><p>会在鼠标右键点击出现，gitbash 以及 git gui</p><h3 id="2-下载node"><a href="#2-下载node" class="headerlink" title="2.下载node"></a>2.下载node</h3><p>地址：<a href="https://nodejs.org/zh-cn/">https://nodejs.org/zh-cn/</a></p><p>直至安装完成<br>npm install -g hexo-cli</p><p>window用户，可以通过以下方法检测安装是否成功<br>进入cmd<br>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo -V</span><br></pre></td></tr></table></figure><p>会出现以下代码则为成功<br>$ hexo-cli: 3.1.0<br>    数字可能会不一样</p><p>一般都会成功</p><h3 id="3-前往github"><a href="#3-前往github" class="headerlink" title="3.前往github"></a>3.前往github</h3><p>申请好github的账户</p><p>创建一个仓库<br>最好命名为</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ 你的github名字.github.io</span><br></pre></td></tr></table></figure><p>这里就不论述了</p><p>至此准备工作完成</p><h2 id="二-开始搭建"><a href="#二-开始搭建" class="headerlink" title="二  开始搭建"></a>二  开始搭建</h2><h3 id="1-通过git操作hexo"><a href="#1-通过git操作hexo" class="headerlink" title="1. 通过git操作hexo"></a>1. 通过git操作hexo</h3><p>进入创建的新文件夹    HEXO<br>右键打开git bash的命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init初始化hexo</span><br></pre></td></tr></table></figure><p>此时会在新文件夹里出现好多文件<br>###2. 寻找喜欢的hexo主题</p><p>地址：<a href="https://hexo.io/themes/">https://hexo.io/themes/</a><br>在里边会有主题<br>随意选择，进入github下载</p><p>将下载好的压缩包进行解压，放置到上一步新建文件夹HEXO目录下的themes文件夹里</p><p>打开HEXO目录下的_config.yml 文件<br>找到最后theme：    修改为刚解压缩的文件名</p><p>顺便在最后加入<br><img src="./1.jpg"></p><h3 id="3-再次通过git命令行操作"><a href="#3-再次通过git命令行操作" class="headerlink" title="3. 再次通过git命令行操作"></a>3. 再次通过git命令行操作</h3><p>输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo clean 格式化</span><br></pre></td></tr></table></figure><p>成功后</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g   生成静态文件</span><br><span class="line">$ hexo s     生成本地网页</span><br></pre></td></tr></table></figure><p>此时在浏览器输入    <a href="http://localhost:4000/">http://localhost:4000/</a>    便会发现一个很low的页面</p><br><h2 id="三-本地博客上传github"><a href="#三-本地博客上传github" class="headerlink" title="三 本地博客上传github"></a>三 本地博客上传github</h2><h3 id="配置key"><a href="#配置key" class="headerlink" title="配置key"></a>配置key</h3><p>进入git bash界面<br>配置</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&quot;yourname&quot;</span></span><br><span class="line">$ git config --global user.email <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>利用下边检测有没有输对</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config  user.name </span><br><span class="line">$ git config  user.email </span><br></pre></td></tr></table></figure><p>然后创建SSH,一路回车</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail&quot;</span></span><br></pre></td></tr></table></figure><p>这时候会告诉你产生了  .ssh 文件夹，在电脑中找到那个文件夹<br>复制 id_rsa.pub（公共密钥）中 文件到github<br><img src="./2.jpg"></p><p>###将公钥添加到GitHub上</p><p>·点击用户头像-&gt;settings-&gt;SSH and GPG keys -&gt;New SSH key</p><p>·将id_rsa.pub中的内容复制到key-&gt;文本框中，然后点击Add SSH key(添加SSH)按钮</p><p>测试<br><img src="./3.jpg"><br><img src="./4.jpg"></p><p>第一次上传会出现</p><p><img src="./5.jpg"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com不需要更改测试联通</span><br></pre></td></tr></table></figure><h2 id="将hexo部署到github"><a href="#将hexo部署到github" class="headerlink" title="将hexo部署到github"></a>将hexo部署到github</h2><p>我们就可以将hexo和GitHub关联起来，也就是将hexo生成的文章部署到GitHub上，打开站点配置文件 </p><p> $_config.yml  翻到最后，修改为YourgithubName就是你的GitHub账户名称</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repo: https://github.com/YourgithubName/YourgithubName.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>此时就完成了本地部署</p><p>$ 打开git bash</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ git g  生成本地</span><br><span class="line"></span><br><span class="line">$ npm install -g hexo</span><br><span class="line"></span><br><span class="line">$ npm install hexo-deployer-git --save 安装部署插件</span><br><span class="line"></span><br><span class="line">$ hexp deploy    部署 可简写成 hexo d</span><br></pre></td></tr></table></figure><h3 id="此时你就可以在上边访问了"><a href="#此时你就可以在上边访问了" class="headerlink" title="此时你就可以在上边访问了"></a>此时你就可以在上边访问了</h3><p>输入  你的github名字.github.io  就可访问了</p><h2 id="上传文章"><a href="#上传文章" class="headerlink" title="上传文章"></a>上传文章</h2><p>使用git bash命令行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new  1创建以1为名字的博客文章</span><br></pre></td></tr></table></figure><p>这个文章在    Hexo\source_posts 下，这是固定的</p><p>在这个下边打开编辑 1.md</p><h3 id="编辑完成"><a href="#编辑完成" class="headerlink" title="编辑完成"></a>编辑完成</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo s 本地查看一下</span><br><span class="line">$ hexo g -deploy      上传</span><br></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/AinUser/article/details/77609180?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param">https://blog.csdn.net/AinUser/article/details/77609180?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param</a></p><p>现在我们就完成上传文章了</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> -git -hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
